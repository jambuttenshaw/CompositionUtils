#include "/Engine/Private/Common.ush"
#include "/Engine/Private/ScreenPass.ush"


/////~~~--- CALIBRATION ---~~~/////

Texture2D<float4> InDepthTexture;
SamplerState DepthTextureSampler;

RWStructuredBuffer<float3> RWCalibrationPoints;

float4x4 SourceNDCToView;

uint NumPoints;
float4 RulersMinAndMax; // AABB defined by [RulersMinAndMax.xy, RulersMinAndMax.zw]

float2 GenerateCalibrationPointUV(uint PointIndex)
{
	const float GoldenRatio = 1.61803398875f;

	float x = (PointIndex + 1) * GoldenRatio;
	float2 UV = float2(
		x % 1.0f,
		(float) (PointIndex + 1) / (float) (NumPoints + 1)
	);

	float2 Extent = RulersMinAndMax.zw - RulersMinAndMax.xy;
	float2 RescaledUV = RulersMinAndMax.xy + UV * Extent;

	return RescaledUV;
}

[numthreads(THREADGROUP_SIZE_1D, 1, 1)]
void SpawnPointsAndDeprojectCS(uint3 DTid : SV_DispatchThreadID)
{
	uint PointID = DTid.x;
	if (PointID >= NumPoints)
	{
		return;
	}

	// Generate sample
	float2 PointUV = GenerateCalibrationPointUV(PointID);

	// Transform into world space

	// De-project pixel into view space
	float4 NDC = float4(PointUV * 2.0f - 1.0f, 0.0f, 1.0f);
	NDC.y = -NDC.y; // UV space has y-axis flipped from NDC

	float4 Deprojected = mul(NDC, SourceNDCToView);

	float Depth = InDepthTexture.Sample(DepthTextureSampler, PointUV).r;
	float3 PointWS = Deprojected.xyz * Depth;

	RWCalibrationPoints[PointID] = PointWS;
}

SCREEN_PASS_TEXTURE_VIEWPORT(OutViewPort)
SCREEN_PASS_TEXTURE_VIEWPORT(InViewPort)

Texture2D InTex;
SamplerState sampler0;

uint bShowPoints;

float4 VisualizePointSpawningPS(float2 InUV : TEXCOORD0) : SV_Target
{
	float4 DepthSample = InTex.Sample(sampler0, InUV);

	float Depth = DepthSample.x;
	bool bValid = DepthSample.w > 0.0f;

	uint Cropped = (InUV.x < RulersMinAndMax.x)
				 + (InUV.y < RulersMinAndMax.y)
				 + (InUV.x > RulersMinAndMax.z)
				 + (InUV.y > RulersMinAndMax.w);

	bool bIsCoveredByPoint = false;
	for (uint i = 0; i < NumPoints; i++)
	{
		float2 PointUV = GenerateCalibrationPointUV(i);

		float2 PointCoord = PointUV * InViewPort_Extent;
		float2 PixelCoord = InUV * InViewPort_Extent;

		bIsCoveredByPoint |= length(PointCoord - PixelCoord) < 2.0f;
	}

	return float4(Depth, bIsCoveredByPoint && bShowPoints, pow(Cropped / 2.0f, 0.5f), bValid);
}
