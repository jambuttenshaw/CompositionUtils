#include "/Engine/Private/Common.ush"
#include "/Engine/Private/ScreenPass.ush"

SCREEN_PASS_TEXTURE_VIEWPORT(OutViewPort)
SCREEN_PASS_TEXTURE_VIEWPORT(InViewPort)

float4x4 SourceNDCToView;
float4x4 SourceToTargetNodalOffset;
float4x4 TargetViewToNDC;

Texture2D InTex;
SamplerState sampler0; // Bilinear sampler to perform interpolation

float2 CalculateUVMapPS(
	float2 InUV : TEXCOORD0
) : SV_Target0
{
	// De-project pixel into view space
	float4 NDC = float4(InUV * 2.0f - 1.0f, 0.0f, 1.0f);
	NDC.y = -NDC.y; // UV space has y-axis flipped from NDC

	float4 Deprojected = mul(NDC, SourceNDCToView);

	float Depth = InTex.Sample(sampler0, InUV).r;
	float4 ViewSpace = float4(Depth * Deprojected.xyz, 1.0f);

	// Apply nodal offest matrix
	ViewSpace = mul(ViewSpace, SourceToTargetNodalOffset);

	// Re-project back into screen space
	NDC = mul(ViewSpace, TargetViewToNDC);
	NDC /= NDC.w;

	float2 OutUV = NDC.xy * 0.5f + 0.5f;
	OutUV.y = 1.0f - OutUV.y;

	if (any(OutUV < 0.0f) || any(OutUV > 1.0f))
	{
		OutUV = -1;
	}

	return OutUV;
}

#ifndef THREADGROUP_SIZE_1D
#define THREADGROUP_SIZE_1D 1
#endif

#ifndef THREADGROUP_SIZE_2D
#define THREADGROUP_SIZE_2D 1
#endif

Texture2D<float4> InDepthTexture;
RWTexture2D<float4> OutDepthTexture;

Texture2D<float2> InUVMap;

// Alignment requires atomics - so must use buffers of integer types
//
// Packing:
// Top 32 bits:   depth as uint
// Next 8 bits:   flags
//		7 bits unused
//		1 bit valid flag
//
// Final 24 bits: Linear pixel index
// 
//     |      depth      |  |flags|  |pixel|
//	0x 0000 0000 0000 0000    00     00 0000
//

Buffer<uint64_t> InBuffer;
RWStructuredBuffer<uint64_t> OutBuffer;

RWStructuredBuffer<uint64_t> InitialClearBuffer;

uint2 ViewDims;

[numthreads(THREADGROUP_SIZE_2D, THREADGROUP_SIZE_2D, 1)]
void ConvertDepthTextureToBufferCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint2 PixelCoord = DispatchThreadId.xy;
	if (any(PixelCoord >= ViewDims))
	{
		return;
	}

	float4 DepthValue = InDepthTexture[PixelCoord];

	uint Index = PixelCoord.y * ViewDims.x + PixelCoord.x;

	// Pixels with alpha of 0 are invalid/clipped
	bool bValidFlag = DepthValue.a > 0.0f;

	// Using trick of interpreting float as uint to be use atomic min/max on float types from https://www.jeremyong.com/graphics/2023/09/05/f32-interlocked-min-max-hlsl/
	uint DepthAsUint = asuint(DepthValue.r);
	if ((DepthAsUint >> 31) == 0)
		DepthAsUint = DepthAsUint | (1u << 31);
	else
		DepthAsUint = ~DepthAsUint;

	uint64_t DepthAsUint64 = DepthAsUint;
	uint64_t IndexAsUint64 = Index;
	uint64_t FlagsAsUint64 = bValidFlag;

	uint64_t OutData = ((DepthAsUint64 << 32) & 0xFFFFFFFF00000000)
					 | ((FlagsAsUint64 << 24) & 0x00000000FF000000)
					 | ( IndexAsUint64        & 0x0000000000FFFFFF);
	OutBuffer[Index] = OutData;

	InitialClearBuffer[Index] = 0xFF80000000000000;
}

// Due to differences in FOV, some pixels could remain blank resulting in holes in the output
// To help alleviate this, each depth pixel can be extended to larger patches to avoid holes at the cost of resolution
uint2 PatchSize;

[numthreads(THREADGROUP_SIZE_2D, THREADGROUP_SIZE_2D, 1)]
void AlignDepthToColorCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint2 PixelCoord = DispatchThreadId.xy;
	if (any(PixelCoord >= ViewDims))
	{
		return;
	}

	uint Index = PixelCoord.y * ViewDims.x + PixelCoord.x;
	uint64_t InData = InBuffer[Index];

	float2 MappedUV = InUVMap[PixelCoord];
	if (any(MappedUV < 0.0f))
	{
		return;
	}

	uint2 MappedPixelCoord = MappedUV * ViewDims;

	for (uint y = 0; y < PatchSize.y; y++)
	{
		for (uint x = 0; x < PatchSize.x; x++)
		{
			uint2 OutPixelCoord = min(MappedPixelCoord + uint2(x, y), ViewDims - 1);
			uint MappedIndex = OutPixelCoord.y * ViewDims.x + OutPixelCoord.x;

			uint Dummy;
			InterlockedMin(OutBuffer[MappedIndex], InData, Dummy);
		}
	}
}

[numthreads(THREADGROUP_SIZE_2D, THREADGROUP_SIZE_2D, 1)]
void ConvertBufferToDepthTextureCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint2 PixelCoord = DispatchThreadId.xy;
	if (any(PixelCoord >= ViewDims))
	{
		return;
	}

	uint Index = PixelCoord.y * ViewDims.x + PixelCoord.x;
	uint64_t InData = InBuffer[Index];
	uint DepthAsUint = uint(InData >> 32);
	uint OriginalIndex = uint(InData & 0x0000000000FFFFFF); // The pixel index that this depth value originated from
	bool bValidFlag = (InData & 0x0000000001000000);

	// Using trick of interpreting float as uint to be use atomic min/max on float types from https://www.jeremyong.com/graphics/2023/09/05/f32-interlocked-min-max-hlsl/
	float DepthValue;
	if (DepthAsUint >> 31 == 0)
	{
		DepthValue = asfloat(~DepthAsUint);
	}
	else
	{
		DepthValue = asfloat(DepthAsUint & ~(1u << 31));
	}

	// Calculate inverse UV map
	uint2 OriginalPixelCoord = uint2(OriginalIndex % ViewDims.x, OriginalIndex / ViewDims.x);
	float2 OriginalUV = OriginalPixelCoord / float2(ViewDims - 0.5f);

	float4 Output = float4(DepthValue, OriginalUV, bValidFlag);
	OutDepthTexture[PixelCoord] = Output;
}


/////////////////////
// Texture Mapping //
/////////////////////

Texture2D<float4> InTextureToMap;
Texture2D<float4> InAlignedDepth;

float4 TextureMappingPS(
	float2 InUV : TEXCOORD0
) : SV_Target0
{
	const float4 CameraDepthData = InAlignedDepth.Sample(sampler0, InUV);

	const bool bDepthValid = CameraDepthData.a != 0;
	float2 AlignedUV = CameraDepthData.gb;

	if (!bDepthValid || any(AlignedUV < 0.0f) || any(AlignedUV > 1.0f))
	{
		return float4(1.0f, 0.0f, 1.0f, 1.0f);
	}

	return InTextureToMap.Sample(sampler0, AlignedUV);
}
