#include "/Engine/Private/Common.ush"
#include "/Engine/Private/ScreenPass.ush"

SCREEN_PASS_TEXTURE_VIEWPORT(OutViewPort)
SCREEN_PASS_TEXTURE_VIEWPORT(InViewPort)

float4x4 PhysicalNDCToView;
float4 InvDeviceZToWorldZTransform;

float4x4 PhysicalToVirtualOffset;
float4x4 VirtualViewToNDC;

Texture2D InTex;
SamplerState sampler0; // Bilinear sampler to perform interpolation

float2 CalculateUVMapPS(
	float2 InUV : TEXCOORD0
) : SV_Target0
{
	float Depth = InTex.Sample(sampler0, InUV).r;
	float DeviceZ = 1.0f / ((Depth + InvDeviceZToWorldZTransform[3]) * InvDeviceZToWorldZTransform[2]);

	// De-project pixel into view space
	float4 NDC = float4(InUV * 2.0f - 1.0f, DeviceZ, 1.0f);
	NDC.y = -NDC.y; // UV space has y-axis flipped from NDC

	float4 Deprojected = mul(NDC, PhysicalNDCToView);
	float4 ViewSpace = Deprojected / Deprojected.w;

	// Apply nodal offest matrix
	ViewSpace = mul(ViewSpace, PhysicalToVirtualOffset);

	// Re-project back into screen space
	NDC = mul(ViewSpace, VirtualViewToNDC);
	NDC /= NDC.w;

	float2 OutUV = NDC.xy * 0.5f + 0.5f;
	OutUV.y = 1.0f - OutUV.y;

	if (any(OutUV < 0.0f) || any(OutUV > 1.0f))
	{
		OutUV = -1;
	}

	return OutUV;
}

#ifndef THREADGROUP_SIZE_1D
#define THREADGROUP_SIZE_1D 1
#endif

#ifndef THREADGROUP_SIZE_2D
#define THREADGROUP_SIZE_2D 1
#endif

Texture2D<float4> InDepthTexture;
RWTexture2D<float4> OutDepthTexture;

Texture2D<float2> InUVMap;

// Alignment requires atomics - so must use buffers of integer types
Buffer<uint64_t> InBuffer;
RWStructuredBuffer<uint64_t> OutBuffer;

RWStructuredBuffer<uint64_t> InitialClearBuffer;

uint2 ViewDims;

[numthreads(THREADGROUP_SIZE_2D, THREADGROUP_SIZE_2D, 1)]
void ConvertDepthTextureToBufferCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint2 PixelCoord = DispatchThreadId.xy;
	if (any(PixelCoord >= ViewDims))
	{
		return;
	}

	float4 DepthValue = InDepthTexture[PixelCoord];

	uint Index = PixelCoord.y * ViewDims.x + PixelCoord.x;

	// Pixels with alpha of 0 are invalid/clipped
	bool bValidFlag = DepthValue.a > 0.0f;

	// Using trick of interpreting float as uint to be use atomic min/max on float types from https://www.jeremyong.com/graphics/2023/09/05/f32-interlocked-min-max-hlsl/
	uint DepthAsUint = bValidFlag ? asuint(DepthValue.r) : 0xFF800000;
	if ((DepthAsUint >> 31) == 0)
		DepthAsUint = DepthAsUint | (1u << 31);
	else
		DepthAsUint = ~DepthAsUint;

	uint64_t DepthAsUint64 = DepthAsUint;
	uint64_t IndexAsUint64 = Index;

	uint64_t OutData = ((DepthAsUint64 << 32) & 0xFFFFFFFF00000000)
					 | ( IndexAsUint64        & 0x0000000000FFFFFF);
	OutBuffer[Index] = OutData;

	InitialClearBuffer[Index] = 0xFF80000000000000;
}

// Due to differences in FOV, some pixels could remain blank resulting in holes in the output
// To help alleviate this, each depth pixel can be extended to larger patches to avoid holes at the cost of resolution
uint2 PatchSize;

[numthreads(THREADGROUP_SIZE_2D, THREADGROUP_SIZE_2D, 1)]
void AlignDepthToColorCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint2 PixelCoord = DispatchThreadId.xy;
	if (any(PixelCoord >= ViewDims))
	{
		return;
	}

	uint Index = PixelCoord.y * ViewDims.x + PixelCoord.x;
	uint64_t InData = InBuffer[Index];

	float2 MappedUV = InUVMap[PixelCoord];
	if (any(MappedUV < 0.0f))
	{
		return;
	}

	uint2 MappedPixelCoord = MappedUV * ViewDims;

	for (uint y = 0; y < PatchSize.y; y++)
	{
		for (uint x = 0; x < PatchSize.x; x++)
		{
			uint2 OutPixelCoord = min(MappedPixelCoord + uint2(x, y), ViewDims - 1);
			uint MappedIndex = OutPixelCoord.y * ViewDims.x + OutPixelCoord.x;

			uint Dummy;
			InterlockedMin(OutBuffer[MappedIndex], InData, Dummy);
		}
	}
}

[numthreads(THREADGROUP_SIZE_2D, THREADGROUP_SIZE_2D, 1)]
void ConvertBufferToDepthTextureCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint2 PixelCoord = DispatchThreadId.xy;
	if (any(PixelCoord >= ViewDims))
	{
		return;
	}

	uint Index = PixelCoord.y * ViewDims.x + PixelCoord.x;
	uint64_t InData = InBuffer[Index];
	uint DepthAsUint = uint(InData >> 32);
	uint OriginalIndex = uint(InData & 0x0000000000FFFFFF); // The pixel index that this depth value originated from

	// Using trick of interpreting float as uint to be use atomic min/max on float types from https://www.jeremyong.com/graphics/2023/09/05/f32-interlocked-min-max-hlsl/
	float DepthValue;
	if (DepthAsUint >> 31 == 0)
	{
		DepthValue = asfloat(~DepthAsUint);
	}
	else
	{
		DepthValue = asfloat(DepthAsUint & ~(1u << 31));
	}

	bool bValid = !isinf(DepthValue);

	// Calculate inverse UV map
	uint2 OriginalPixelCoord = uint2(OriginalIndex % ViewDims.x, OriginalIndex / ViewDims.x);
	float2 OriginalUV = OriginalPixelCoord / float2(ViewDims - 0.5f);

	float4 Output = float4(DepthValue, OriginalUV, bValid);
	OutDepthTexture[PixelCoord] = Output;
}



/////~~~--- CALIBRATION ---~~~/////

SamplerState DepthTextureSampler;
RWStructuredBuffer<float3> RWCalibrationPoints;

uint NumPoints;
float4 RulersMinAndMax; // AABB defined by [RulersMinAndMax.xy, RulersMinAndMax.zw]

float2 GenerateCalibrationPointUV(uint PointIndex)
{
	const float GoldenRatio = 1.61803398875f;

	float x = (PointIndex + 1) * GoldenRatio;
	float2 UV = float2(
		x % 1.0f,
		(float)(PointIndex + 1) / (float)(NumPoints + 1)
	);

	float2 Extent = RulersMinAndMax.zw - RulersMinAndMax.xy;
	float2 RescaledUV = RulersMinAndMax.xy + UV * Extent;

	return RescaledUV;
}

[numthreads(THREADGROUP_SIZE_1D, 1, 1)]
void SpawnPointsAndDeprojectCS(uint3 DTid : SV_DispatchThreadID)
{
	uint PointID = DTid.x;
	if (PointID >= NumPoints)
	{
		return;
	}

	// Generate sample
	float2 PointUV = GenerateCalibrationPointUV(PointID);

	// Transform into world space
	float Depth = InDepthTexture.Sample(DepthTextureSampler, PointUV).r;
	float DeviceZ = 1.0f / ((Depth + InvDeviceZToWorldZTransform[3]) * InvDeviceZToWorldZTransform[2]);

	// De-project pixel into view space
	float4 NDC = float4(PointUV * 2.0f - 1.0f, DeviceZ, 1.0f);
	NDC.y = -NDC.y; // UV space has y-axis flipped from NDC

	float4 Deprojected = mul(NDC, PhysicalNDCToView);
	float3 PointWS = Deprojected.xyz / Deprojected.w;

	RWCalibrationPoints[PointID] = PointWS;
}


uint bShowPoints;

float4 VisualizePointSpawningPS(float2 InUV : TEXCOORD0) : SV_Target
{
	float4 DepthSample = InTex.Sample(sampler0, InUV);

	float Depth = DepthSample.x;
	bool bValid = DepthSample.w > 0.0f;

	uint Cropped = (InUV.x < RulersMinAndMax.x)
				 + (InUV.y < RulersMinAndMax.y)
				 + (InUV.x > RulersMinAndMax.z)
				 + (InUV.y > RulersMinAndMax.w);

	bool bIsCoveredByPoint = false;
	for (uint i = 0; i < NumPoints; i++)
	{
		float2 PointUV = GenerateCalibrationPointUV(i);

		float2 PointCoord = PointUV * InViewPort_Extent;
		float2 PixelCoord = InUV * InViewPort_Extent;

		bIsCoveredByPoint |= length(PointCoord - PixelCoord) < 2.0f;
	}

	return float4(Depth, bIsCoveredByPoint && bShowPoints, pow(Cropped / 2.0f, 0.5f), bValid);
}
