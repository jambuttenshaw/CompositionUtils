#include "/Engine/Private/Common.ush"
#include "/Engine/Private/ScreenPass.ush"

SCREEN_PASS_TEXTURE_VIEWPORT(OutViewPort)
SCREEN_PASS_TEXTURE_VIEWPORT(InViewPort)

float4x4 PhysicalNDCToView;
float4 InvDeviceZToWorldZTransform;

float4x4 PhysicalToVirtualOffset;
float4x4 VirtualViewToNDC;

Texture2D InTex;
SamplerState sampler0; // Bilinear sampler to perform interpolation

float2 CalculateUVMapPS(
	float2 InUV : TEXCOORD0
) : SV_Target0
{
	float Depth = InTex.Sample(sampler0, InUV).r;
	float DeviceZ = 1.0f / ((Depth + InvDeviceZToWorldZTransform[3]) * InvDeviceZToWorldZTransform[2]);

	// De-project pixel into view space
	float4 NDC = float4(InUV * 2.0f - 1.0f, DeviceZ, 1.0f);
	NDC.y = -NDC.y; // UV space has y-axis flipped from NDC

	float4 Deprojected = mul(NDC, PhysicalNDCToView);
	float4 ViewSpace = Deprojected / Deprojected.w;

	// Apply nodal offest matrix
	ViewSpace = mul(ViewSpace, PhysicalToVirtualOffset);

	// Re-project back into screen space
	NDC = mul(ViewSpace, VirtualViewToNDC);
	NDC /= NDC.w;

	float2 OutUV = NDC.xy * 0.5f + 0.5f;
	OutUV.y = 1.0f - OutUV.y;

	if (any(OutUV < 0.0f) || any(OutUV > 1.0f))
	{
		OutUV = -1;
	}

	return OutUV;
}


#ifndef THREADGROUP_SIZE_2D
#define THREADGROUP_SIZE_2D 1
#endif

Texture2D<float4> InDepthTexture;
RWTexture2D<float4> OutDepthTexture;

Texture2D<float2> InUVMap;

// Alignment requires atomics - so must use buffers of integer types
Buffer<uint> InBuffer;
RWBuffer<uint> OutBuffer;

uint2 ViewDims;

[numthreads(THREADGROUP_SIZE_2D, THREADGROUP_SIZE_2D, 1)]
void ConvertDepthTextureToBufferCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint2 PixelCoord = DispatchThreadId.xy;
	if (any(PixelCoord >= ViewDims))
	{
		return;
	}

	float4 DepthValue = InDepthTexture[PixelCoord];

	uint Index = PixelCoord.y * ViewDims.x + PixelCoord.x;

	// Pixels with alpha of 0 are invalid/clipped
	uint ValidFlag = DepthValue.a > 0.0f;

	// Using trick of interpreting float as uint to be use atomic min/max on float types from https://www.jeremyong.com/graphics/2023/09/05/f32-interlocked-min-max-hlsl/
	uint DepthAsUint = asuint(DepthValue.r);
	if ((DepthAsUint >> 31) == 0)
		DepthAsUint = DepthAsUint | (1u << 31);
	else
		DepthAsUint = ~DepthAsUint;

	OutBuffer[Index] = ValidFlag ? DepthAsUint : 0;
}

// Due to differences in FOV, some pixels could remain blank resulting in holes in the output
// To help alleviate this, each depth pixel can be extended to larger patches to avoid holes at the cost of resolution
uint2 PatchSize;

[numthreads(THREADGROUP_SIZE_2D, THREADGROUP_SIZE_2D, 1)]
void AlignDepthToColorCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint2 PixelCoord = DispatchThreadId.xy;
	if (any(PixelCoord >= ViewDims))
	{
		return;
	}

	uint Index = PixelCoord.y * ViewDims.x + PixelCoord.x;
	uint InData = InBuffer[Index];

	float2 MappedUV = InUVMap[PixelCoord];
	if (any(MappedUV < 0.0f))
	{
		InData = 0;
	}

	// No valid data - this will never win InterlockedMax
	if (InData == 0)
		return;

	uint2 MappedPixelCoord = MappedUV * ViewDims;

	for (uint y = 0; y < PatchSize.y; y++)
	{
		for (uint x = 0; x < PatchSize.x; x++)
		{
			uint2 OutPixelCoord = min(MappedPixelCoord + uint2(x, y), ViewDims - 1);
			uint MappedIndex = OutPixelCoord.y * ViewDims.x + OutPixelCoord.x;

			uint Dummy;
			InterlockedMax(OutBuffer[MappedIndex], InData, Dummy);
		}
	}
}

[numthreads(THREADGROUP_SIZE_2D, THREADGROUP_SIZE_2D, 1)]
void ConvertBufferToDepthTextureCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint2 PixelCoord = DispatchThreadId.xy;
	if (any(PixelCoord >= ViewDims))
	{
		return;
	}

	uint Index = PixelCoord.y * ViewDims.x + PixelCoord.x;
	uint DepthAsUint = InBuffer[Index];

	uint ValidFlag = DepthAsUint != 0;

	// Using trick of interpreting float as uint to be use atomic min/max on float types from https://www.jeremyong.com/graphics/2023/09/05/f32-interlocked-min-max-hlsl/
	float DepthValue;
	if (DepthAsUint >> 31 == 0)
	{
		DepthValue = asfloat(~DepthAsUint);
	}
	else
	{
		DepthValue = asfloat(DepthAsUint & ~(1u << 31));
	}

	float4 Output = ValidFlag ? float4(DepthValue.xxx, 1.0f) : 0.0f;
	OutDepthTexture[PixelCoord] = Output;
}
